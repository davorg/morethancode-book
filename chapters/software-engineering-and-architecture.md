# Software engineering and architecture

As a software engineer, it should be obvious that it's a good idea to keep up
to date with the latest ideas in designing software system. In this chapter,
we'll look at some modern ideas in this field.

## Software development lifecycle

* Agile vs Waterfall
* Agile manifesto
* Scrum vs kanban vs extreme programming
* Know your tools
    * Jira
    * Code reviews

We are uncovering better ways of developing software by doing it and helping
others do it. Through this work we have come to value:

* Individuals and interactions over processes and tools
* Working software over comprehensive documentation
* Customer collaboration over contract negotiation
* Responding to change over following a plan

That is, while there is value in the items on the right, we value the items
on the left more.

Individuals and Interactions

* People are more important than processes
* Development teams know how to organise their work
* Business says what they need
* Development team works out how to achieve that
* Giving people more control and responsibility

Working Software

* Documentation is often out of date before it is finished
* Mismatch between business language and technical language
* Business often don't know what they want until they see the options
* Build prototypes and discuss alternatives

Customer Collaboration

* Don't just involve users when the project is specified
* Have user representatives as a part of the development team
* Instant response to developer questions
* More involvement leads to more business ownership of project

Responding to Change

* Requirements will change during the project lifetime
* Be flexible
* Plan for change

## Programming paradigms

What paradigms does your system use?

* Procedural
* Object Oriented
* Functional
* Who made those choices?
* Why?

Procedural Programming

* Dumb variables
* Procedures, functions
* Hard to maintain
* Hard to scale

Object Oriented Programming

* Classes define both data (attributes) and behaviour (methods)
* Intelligent variables
* Encapsulation
* Subclassing
* Easy to maintain
* Easy to scale

Functional Programming

* Pure functions
    * Take inputs, return values
    * No global variables
* Immutable variables
* Prefer recursion to loops
* Easier to maintain
* Good for asynchronous programming

## Design patterns

* "Gang of Four" book
* "Monolithic" architecture
* Service Oriented Architecture
* Microservices

The Power of Names

* Design patterns weren't new or exciting
* Naming them was
* Catalogue of known techniques
* Easier to discuss
* Easier to share
